---
title: "Грамматика обращения с данными"
subtitle: "<br><br> Data Science in a Box"
author: "[datasciencebox.org](https://datasciencebox.org/)"
output:
  xaringan::moon_reader:
    css: ["../xaringan-themer.css", "../slides.css"]
    lib_dir: libs
    nature:
      ratio: "16:9"
      highlightLines: true
      highlightStyle: solarized-light
      countIncrementalSlides: false
---

```{r child = "../setup.Rmd"}
```

```{r packages, echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
```

class: middle

# Грамматика обращения с данными

---

## Грамматика обращения с данными...

... основана на концепции функций как глаголов, которые манипулируют фреймами

.pull-left[
```{r dplyr-part-of-tidyverse, echo=FALSE, out.width="70%", caption = "dplyr is part of the tidyverse"}
knitr::include_graphics("img/dplyr-part-of-tidyverse.png")
```
]
.pull-right[
.midi[
- `select`: выбрать столбцы по имени
- `arrange`: упорядочить строки
- `slice`: выбрать строки с помощью индекса
- `filter`: выбрать строки в соответствии с критерием
- `distinct`: отфильтровать уникальные строки
- `mutate`: добавить новые переменные
- `summarise`: редуцировать переменные до значений
- `group_by`: для групповых операций
- ... (и многое другое)
]
]

---

## Принципы функций **dplyr**

- Первый аргумент - это *всегда* фрейм
- Последующие аргументы указывают, что сделать с этим фреймом
- Всегда возвращается фрейм
- Не делается модификация на месте (в исходном фрейме)

---

## Данные: Бринирование отелей

- Данные по двум отелям: одному курортному и одному городскому
- Наблюдения: Каждая строка - это бронирование
- Цель сбора исходных данных: Разработка прогностической модели для классификации бронирований по вероятности отмены ([Antonia et al., 2019](https://www.sciencedirect.com/science/article/pii/S2352340918315191#bib5))

```{r message=FALSE}
hotels <- read_csv("data/hotels.csv")
```

.footnote[
Source: [TidyTuesday](https://github.com/rfordatascience/tidytuesday/blob/master/data/2020/2020-02-11/readme.md)
]

---

## Первый взгляд: Переменные

```{r output.lines=18}
names(hotels)
```

---

## Второй взгляд: Обзор

```{r output.lines=18}
glimpse(hotels)
```

---

## Выбираем один столбец

Просмотрим только `lead_time` (число дней между бронированием и датой заезда):

```{r}
select(hotels, lead_time)
```

---

## Выбираем один столбец

.pull-left[
```{r eval=FALSE}
select( #<<
  hotels, 
  lead_time
  )
```
]
.pull-right[
- Начинаем с имени функции (глагол): `select()`
]

---

## Выбираем один столбец

.pull-left[
```{r eval=FALSE}
select( 
  hotels, #<<
  lead_time
  )
```
]
.pull-right[
- Начинаем с имени функции (глагол): `select()`
- Первый аргумент: данные, с которыми нужно работать, `hotels`
]

---

## Выбираем один столбец

.pull-left[
```{r eval=FALSE}
select( 
  hotels, 
  lead_time #<<
  )
```
]
.pull-right[
- Начинаем с имени функции (глагол): `select()`
- Первый аргумент: данные, с которыми нужно работать, `hotels`
- Второй аргумент: переменная, которую надо выбрать, `lead_time`
]

---

## Выбираем один столбец

.pull-left[
```{r}
select( 
  hotels, 
  lead_time
  )
```
]
.pull-right[
- Начинаем с имени функции (глагол): `select()`
- Первый аргумент: данные, с которыми нужно работать, `hotels`
- Второй аргумент: переменная, которую надо выбрать, `lead_time`
- Результат: фрейм из `r nrow(hotels)` строк и одного столбца
]

---

.tip[
функции dplyr всегда получают фрейм и всегда возвращают фрейм.
]

```{r}
select(hotels, lead_time)
```

---

## Выбираем несколько столбцов


Просмотрим только тип отеля `hotel` и `lead_time`:

--

.pull-left[
```{r}
select(hotels, hotel, lead_time)
```
]
--
.pull-right[
.question[
А что, если мы захотим выбрать эти столбцы, а потом еще и упорядочить данные в порядке убывания переменной `lead time`?
]
]

---

## Манипулирование данными, шаг за шагом

.pull-left[
Select:
```{r}
hotels %>%
  select(hotel, lead_time)
```
]

--
.pull-right[
Выбираем, затем упорядочиваем:
```{r}
hotels %>%
  select(hotel, lead_time) %>%
  arrange(desc(lead_time))
```
]

---

class: middle

# Pipes

---

## Что такое pipe?

В программировании, pipe - это техника передачи информации от одного процесса к другому.

--

.pull-left[
- Начинаем с фрейма `hotels`, передаем его функции `select()`,
]
.pull-right[
.small[
```{r}
hotels %>% #<<
  select(hotel, lead_time) %>%
  arrange(desc(lead_time))
```
]
]

---

## Что такое pipe?

В программировании, pipe - это техника передачи информации от одного процесса к другому.

.pull-left[
- Начинаем с фрейма `hotels`, передаем его функции `select()`,
- затем выбираем переменные `hotel` и `lead_time`,
]
.pull-right[
.small[
```{r}
hotels %>%
  select(hotel, lead_time) %>% #<<
  arrange(desc(lead_time))
```
]
]

---

## Что такое pipe?

В программировании, pipe - это техника передачи информации от одного процесса к другому.

.pull-left[
- Начинаем с фрейма `hotels`, передаем его функции `select()`,
- затем выбираем переменные `hotel` и `lead_time`,
- затем упорядочиваем фрейм по переменной `lead_time` в порядке убывания.
]
.pull-right[
.small[
```{r}
hotels %>%
  select(hotel, lead_time) %>% 
  arrange(desc(lead_time)) #<<
```
]
]

---

## Aside

The pipe operator is implemented in the package **magrittr**, though we don't need to load this package explicitly since **tidyverse** does this for us.

--

.question[
Any guesses as to why the package is called magrittr?
]

--

.pull-left[
```{r magritte, echo=FALSE, out.width="90%", caption = "Magritte's pipe"}
knitr::include_graphics("img/magritte.jpg")
```
]
.pull-right[
```{r magrittr, echo=FALSE, out.width="100%", caption = "magrittr's pipe"}
knitr::include_graphics("img/magrittr.jpg")
```
]

---

## How does a pipe work?

- You can think about the following sequence of actions - find keys, 
unlock car, start car, drive to work, park.

--
- Expressed as a set of nested functions in R pseudocode this would look like:
```{r eval=FALSE}
park(drive(start_car(find("keys")), to = "work"))
```

--
- Writing it out using pipes give it a more natural (and easier to read) 
structure:
```{r eval=FALSE}
find("keys") %>%
  start_car() %>%
  drive(to = "work") %>%
  park()
```

---

## A note on piping and layering

- `%>%` used mainly in **dplyr** pipelines, *we pipe the output of the previous line of code as the first input of the next line of code*

--
- `+` used in **ggplot2** plots is used for "layering", *we create the plot in layers, separated by `+`*

---

## dplyr

.midi[
`r emo::ji("x")`

```{r error=TRUE}
hotels +
  select(hotel, lead_time)
```

`r emo::ji("white_check_mark")`

```{r eval=FALSE}
hotels %>%
  select(hotel, lead_time)
```

```{r echo=FALSE, output.lines=6}
hotels %>%
  select(hotel, lead_time)
```
]

---

## ggplot2

.midi[
`r emo::ji("x")`

```{r error=TRUE}
ggplot(hotels, aes(x = hotel, fill = deposit_type)) %>%
  geom_bar()
```

`r emo::ji("white_check_mark")`

```{r out.width="25%"}
ggplot(hotels, aes(x = hotel, fill = deposit_type)) +
  geom_bar()
```
]

---

## Code styling

Many of the styling principles are consistent across `%>%` and `+`:

- always a space before
- always a line break after (for pipelines with more than 2 lines)

`r emo::ji("x")`

```{r eval=FALSE}
ggplot(hotels,aes(x=hotel,y=deposit_type))+geom_bar()
```

`r emo::ji("white_check_mark")`

```{r eval=FALSE}
ggplot(hotels, aes(x = hotel, y = deposit_type)) + 
  geom_bar()
```
